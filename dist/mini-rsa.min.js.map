{"version":3,"file":"mini-rsa.min.js","sources":["../node_modules/core-js/library/modules/_core.js","../node_modules/core-js/library/fn/json/stringify.js","../src/lib/MiniRSA.js"],"sourcesContent":["var core = module.exports = { version: '2.6.9' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","var core = require('../../modules/_core');\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n","/*!\r\n * RSA library for Node.js\r\n *\r\n * Author: rzcoder\r\n * License MIT\r\n */\r\n\r\nvar constants = require('constants');\r\nvar rsa = require('./libs/rsa.js');\r\nvar crypt = require('crypto');\r\nvar ber = require('asn1').Ber;\r\nvar _ = require('./utils')._;\r\nvar utils = require('./utils');\r\nvar schemes = require('./schemes/schemes.js');\r\nvar formats = require('./formats/formats.js');\r\n\r\nif (typeof constants.RSA_NO_PADDING === \"undefined\") {\r\n    //patch for node v0.10.x, constants do not defined\r\n    constants.RSA_NO_PADDING = 3;\r\n}\r\n\r\nexport default (function () {\r\n    var SUPPORTED_HASH_ALGORITHMS = {\r\n        node10: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\r\n        node: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\r\n        iojs: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\r\n        browser: ['md5', 'ripemd160', 'sha1', 'sha256', 'sha512']\r\n    };\r\n\r\n    var DEFAULT_ENCRYPTION_SCHEME = 'pkcs1_oaep';\r\n    var DEFAULT_SIGNING_SCHEME = 'pkcs1';\r\n\r\n    var DEFAULT_EXPORT_FORMAT = 'private';\r\n    var EXPORT_FORMAT_ALIASES = {\r\n        'private': 'pkcs1-private-pem',\r\n        'private-der': 'pkcs1-private-der',\r\n        'public': 'pkcs8-public-pem',\r\n        'public-der': 'pkcs8-public-der',\r\n    };\r\n\r\n    /**\r\n     * @param key {string|buffer|object} Key in PEM format, or data for generate key {b: bits, e: exponent}\r\n     * @constructor\r\n     */\r\n    function NodeRSA(key, format, options) {\r\n        if (!(this instanceof NodeRSA)) {\r\n            return new NodeRSA(key, format, options);\r\n        }\r\n\r\n        if (_.isObject(format)) {\r\n            options = format;\r\n            format = undefined;\r\n        }\r\n\r\n        this.$options = {\r\n            signingScheme: DEFAULT_SIGNING_SCHEME,\r\n            signingSchemeOptions: {\r\n                hash: 'sha256',\r\n                saltLength: null\r\n            },\r\n            encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,\r\n            encryptionSchemeOptions: {\r\n                hash: 'sha1',\r\n                label: null\r\n            },\r\n            environment: utils.detectEnvironment(),\r\n            rsaUtils: this\r\n        };\r\n        this.keyPair = new rsa.Key();\r\n        this.$cache = {};\r\n\r\n        if (Buffer.isBuffer(key) || _.isString(key)) {\r\n            this.importKey(key, format);\r\n        } else if (_.isObject(key)) {\r\n            this.generateKeyPair(key.b, key.e);\r\n        }\r\n\r\n        this.setOptions(options);\r\n    }\r\n\r\n    /**\r\n     * Set and validate options for key instance\r\n     * @param options\r\n     */\r\n    NodeRSA.prototype.setOptions = function (options) {\r\n        options = options || {};\r\n        if (options.environment) {\r\n            this.$options.environment = options.environment;\r\n        }\r\n\r\n        if (options.signingScheme) {\r\n            if (_.isString(options.signingScheme)) {\r\n                var signingScheme = options.signingScheme.toLowerCase().split('-');\r\n                if (signingScheme.length == 1) {\r\n                    if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {\r\n                        this.$options.signingSchemeOptions = {\r\n                            hash: signingScheme[0]\r\n                        };\r\n                        this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;\r\n                    } else {\r\n                        this.$options.signingScheme = signingScheme[0];\r\n                        this.$options.signingSchemeOptions = {\r\n                            hash: null\r\n                        };\r\n                    }\r\n                } else {\r\n                    this.$options.signingSchemeOptions = {\r\n                        hash: signingScheme[1]\r\n                    };\r\n                    this.$options.signingScheme = signingScheme[0];\r\n                }\r\n            } else if (_.isObject(options.signingScheme)) {\r\n                this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;\r\n                this.$options.signingSchemeOptions = _.omit(options.signingScheme, 'scheme');\r\n            }\r\n\r\n            if (!schemes.isSignature(this.$options.signingScheme)) {\r\n                throw Error('Unsupported signing scheme');\r\n            }\r\n\r\n            if (this.$options.signingSchemeOptions.hash &&\r\n                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) {\r\n                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\r\n            }\r\n        }\r\n\r\n        if (options.encryptionScheme) {\r\n            if (_.isString(options.encryptionScheme)) {\r\n                this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();\r\n                this.$options.encryptionSchemeOptions = {};\r\n            } else if (_.isObject(options.encryptionScheme)) {\r\n                this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;\r\n                this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, 'scheme');\r\n            }\r\n\r\n            if (!schemes.isEncryption(this.$options.encryptionScheme)) {\r\n                throw Error('Unsupported encryption scheme');\r\n            }\r\n\r\n            if (this.$options.encryptionSchemeOptions.hash &&\r\n                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) {\r\n                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\r\n            }\r\n        }\r\n\r\n        this.keyPair.setOptions(this.$options);\r\n    };\r\n\r\n    /**\r\n     * Generate private/public keys pair\r\n     *\r\n     * @param bits {int} length key in bits. Default 2048.\r\n     * @param exp {int} public exponent. Default 65537.\r\n     * @returns {NodeRSA}\r\n     */\r\n    NodeRSA.prototype.generateKeyPair = function (bits, exp) {\r\n        bits = bits || 2048;\r\n        exp = exp || 65537;\r\n\r\n        if (bits % 8 !== 0) {\r\n            throw Error('Key size must be a multiple of 8.');\r\n        }\r\n\r\n        this.keyPair.generate(bits, exp.toString(16));\r\n        this.$cache = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Importing key\r\n     * @param keyData {string|buffer|Object}\r\n     * @param format {string}\r\n     */\r\n    NodeRSA.prototype.importKey = function (keyData, format) {\r\n        if (!keyData) {\r\n            throw Error(\"Empty key given\");\r\n        }\r\n\r\n        if (format) {\r\n            format = EXPORT_FORMAT_ALIASES[format] || format;\r\n        }\r\n\r\n        if (!formats.detectAndImport(this.keyPair, keyData, format) && format === undefined) {\r\n            throw Error(\"Key format must be specified\");\r\n        }\r\n        \r\n        this.$cache = {};\r\n        \r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Exporting key\r\n     * @param [format] {string}\r\n     */\r\n    NodeRSA.prototype.exportKey = function (format) {\r\n        format = format || DEFAULT_EXPORT_FORMAT;\r\n        format = EXPORT_FORMAT_ALIASES[format] || format;\r\n\r\n        if (!this.$cache[format]) {\r\n            this.$cache[format] = formats.detectAndExport(this.keyPair, format);\r\n        }\r\n\r\n        return this.$cache[format];\r\n    };\r\n\r\n    /**\r\n     * Check if key pair contains private key\r\n     */\r\n    NodeRSA.prototype.isPrivate = function () {\r\n        return this.keyPair.isPrivate();\r\n    };\r\n\r\n    /**\r\n     * Check if key pair contains public key\r\n     * @param [strict] {boolean} - public key only, return false if have private exponent\r\n     */\r\n    NodeRSA.prototype.isPublic = function (strict) {\r\n        return this.keyPair.isPublic(strict);\r\n    };\r\n\r\n    /**\r\n     * Check if key pair doesn't contains any data\r\n     */\r\n    NodeRSA.prototype.isEmpty = function (strict) {\r\n        return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);\r\n    };\r\n\r\n    /**\r\n     * Encrypting data method with public key\r\n     *\r\n     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\r\n     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\r\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\r\n     * @returns {string|Buffer}\r\n     */\r\n    NodeRSA.prototype.encrypt = function (buffer, encoding, source_encoding) {\r\n        return this.$$encryptKey(false, buffer, encoding, source_encoding);\r\n    };\r\n\r\n    /**\r\n     * Decrypting data method with private key\r\n     *\r\n     * @param buffer {Buffer} - buffer for decrypting\r\n     * @param encoding - encoding for result string, can also take 'json' or 'buffer' for the automatic conversion of this type\r\n     * @returns {Buffer|object|string}\r\n     */\r\n    NodeRSA.prototype.decrypt = function (buffer, encoding) {\r\n        return this.$$decryptKey(false, buffer, encoding);\r\n    };\r\n\r\n    /**\r\n     * Encrypting data method with private key\r\n     *\r\n     * Parameters same as `encrypt` method\r\n     */\r\n    NodeRSA.prototype.encryptPrivate = function (buffer, encoding, source_encoding) {\r\n        return this.$$encryptKey(true, buffer, encoding, source_encoding);\r\n    };\r\n\r\n    /**\r\n     * Decrypting data method with public key\r\n     *\r\n     * Parameters same as `decrypt` method\r\n     */\r\n    NodeRSA.prototype.decryptPublic = function (buffer, encoding) {\r\n        return this.$$decryptKey(true, buffer, encoding);\r\n    };\r\n\r\n    /**\r\n     * Encrypting data method with custom key\r\n     */\r\n    NodeRSA.prototype.$$encryptKey = function (usePrivate, buffer, encoding, source_encoding) {\r\n        try {\r\n            var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer, source_encoding), usePrivate);\r\n\r\n            if (encoding == 'buffer' || !encoding) {\r\n                return res;\r\n            } else {\r\n                return res.toString(encoding);\r\n            }\r\n        } catch (e) {\r\n            console.log(e);\r\n            throw Error('Error during encryption. Original error: ' + e);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Decrypting data method with custom key\r\n     */\r\n    NodeRSA.prototype.$$decryptKey = function (usePublic, buffer, encoding) {\r\n        try {\r\n            buffer = _.isString(buffer) ? Buffer.from(buffer, 'base64') : buffer;\r\n            var res = this.keyPair.decrypt(buffer, usePublic);\r\n\r\n            if (res === null) {\r\n                throw Error('Key decrypt method returns null.');\r\n            }\r\n\r\n            return this.$getDecryptedData(res, encoding);\r\n        } catch (e) {\r\n            throw Error('Error during decryption (probably incorrect key). Original error: ' + e);\r\n        }\r\n    };\r\n\r\n    /**\r\n     *  Signing data\r\n     *\r\n     * @param buffer {string|number|object|array|Buffer} - data for signing. Object and array will convert to JSON string.\r\n     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\r\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\r\n     * @returns {string|Buffer}\r\n     */\r\n    NodeRSA.prototype.sign = function (buffer, encoding, source_encoding) {\r\n        if (!this.isPrivate()) {\r\n            throw Error(\"This is not private key\");\r\n        }\r\n\r\n        var res = this.keyPair.sign(this.$getDataForEncrypt(buffer, source_encoding));\r\n\r\n        if (encoding && encoding != 'buffer') {\r\n            res = res.toString(encoding);\r\n        }\r\n\r\n        return res;\r\n    };\r\n\r\n    /**\r\n     *  Verifying signed data\r\n     *\r\n     * @param buffer - signed data\r\n     * @param signature\r\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\r\n     * @param signature_encoding - optional. Encoding of given signature. May be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\r\n     * @returns {*}\r\n     */\r\n    NodeRSA.prototype.verify = function (buffer, signature, source_encoding, signature_encoding) {\r\n        if (!this.isPublic()) {\r\n            throw Error(\"This is not public key\");\r\n        }\r\n        signature_encoding = (!signature_encoding || signature_encoding == 'buffer' ? null : signature_encoding);\r\n        return this.keyPair.verify(this.$getDataForEncrypt(buffer, source_encoding), signature, signature_encoding);\r\n    };\r\n\r\n    /**\r\n     * Returns key size in bits\r\n     * @returns {int}\r\n     */\r\n    NodeRSA.prototype.getKeySize = function () {\r\n        return this.keyPair.keySize;\r\n    };\r\n\r\n    /**\r\n     * Returns max message length in bytes (for 1 chunk) depending on current encryption scheme\r\n     * @returns {int}\r\n     */\r\n    NodeRSA.prototype.getMaxMessageSize = function () {\r\n        return this.keyPair.maxMessageLength;\r\n    };\r\n\r\n    /**\r\n     * Preparing given data for encrypting/signing. Just make new/return Buffer object.\r\n     *\r\n     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\r\n     * @param encoding {string} - optional. Encoding for given string. Default utf8.\r\n     * @returns {Buffer}\r\n     */\r\n    NodeRSA.prototype.$getDataForEncrypt = function (buffer, encoding) {\r\n        if (_.isString(buffer) || _.isNumber(buffer)) {\r\n            return Buffer.from('' + buffer, encoding || 'utf8');\r\n        } else if (Buffer.isBuffer(buffer)) {\r\n            return buffer;\r\n        } else if (_.isObject(buffer)) {\r\n            return Buffer.from(JSON.stringify(buffer));\r\n        } else {\r\n            throw Error(\"Unexpected data type\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param buffer {Buffer} - decrypted data.\r\n     * @param encoding - optional. Encoding for result output. May be 'buffer', 'json' or any of Node.js Buffer supported encoding.\r\n     * @returns {*}\r\n     */\r\n    NodeRSA.prototype.$getDecryptedData = function (buffer, encoding) {\r\n        encoding = encoding || 'buffer';\r\n\r\n        if (encoding == 'buffer') {\r\n            return buffer;\r\n        } else if (encoding == 'json') {\r\n            return JSON.parse(buffer.toString());\r\n        } else {\r\n            return buffer.toString(encoding);\r\n        }\r\n    };\r\n\r\n    return NodeRSA;\r\n})();\r\n"],"names":["core","module","version","__e","$JSON","JSON","stringify","it","apply","arguments","constants","require","rsa","_","Ber","utils","schemes","formats","RSA_NO_PADDING","NodeRSA","key","format","options","isObject","this","$options","signingScheme","DEFAULT_SIGNING_SCHEME","signingSchemeOptions","hash","saltLength","encryptionScheme","DEFAULT_ENCRYPTION_SCHEME","encryptionSchemeOptions","label","environment","detectEnvironment","rsaUtils","keyPair","Key","$cache","Buffer","isBuffer","isString","importKey","generateKeyPair","b","e","setOptions","SUPPORTED_HASH_ALGORITHMS","node10","node","iojs","browser","EXPORT_FORMAT_ALIASES","private","private-der","public","public-der","prototype","toLowerCase","split","length","indexOf","scheme","omit","isSignature","Error","isEncryption","bits","exp","generate","toString","keyData","detectAndImport","exportKey","detectAndExport","isPrivate","isPublic","strict","isEmpty","n","d","encrypt","buffer","encoding","source_encoding","$$encryptKey","decrypt","$$decryptKey","encryptPrivate","decryptPublic","usePrivate","res","$getDataForEncrypt","console","log","usePublic","from","$getDecryptedData","sign","verify","signature","signature_encoding","getKeySize","keySize","getMaxMessageSize","maxMessageLength","isNumber","_JSON$stringify","parse"],"mappings":"uWAAA,IAAIA,EAAOC,UAAiB,CAAEC,QAAS,SACrB,iBAAPC,MAAiBA,IAAMH,KCA9BI,aAAQJ,EAAKK,OAASL,EAAKK,KAAO,CAAEC,UAAWD,KAAKC,eACvC,SAAmBC,GAClC,OAAOH,EAAME,UAAUE,MAAMJ,EAAOK,YCIlCC,EAAYC,QAAQ,aACpBC,EAAMD,QAAQ,iBAGdE,GAFQF,QAAQ,UACVA,QAAQ,QAAQG,IAClBH,QAAQ,WAAWE,GACvBE,EAAQJ,QAAQ,WAChBK,EAAUL,QAAQ,wBAClBM,EAAUN,QAAQ,oCAEkB,IAA7BD,EAAUQ,iBAEjBR,EAAUQ,eAAiB,GAGhB,WAuBX,SAASC,EAAQC,EAAKC,EAAQC,0BACJH,GAIlBN,EAAEU,SAASF,KACXC,EAAUD,EACVA,UAGJG,KAAKC,SAAW,CACZC,cAAeC,EACfC,qBAAsB,CAClBC,KAAM,SACNC,WAAY,MAEhBC,iBAAkBC,EAClBC,wBAAyB,CACrBJ,KAAM,OACNK,MAAO,MAEXC,YAAapB,EAAMqB,oBACnBC,SAAUb,MAEdA,KAAKc,QAAU,IAAI1B,EAAI2B,IACvBf,KAAKgB,OAAS,GAEVC,OAAOC,SAAStB,IAAQP,EAAE8B,SAASvB,GACnCI,KAAKoB,UAAUxB,EAAKC,GACbR,EAAEU,SAASH,IAClBI,KAAKqB,gBAAgBzB,EAAI0B,EAAG1B,EAAI2B,QAGpCvB,KAAKwB,WAAW1B,IA/BL,IAAIH,EAAQC,EAAKC,EAAQC,GAzBhB,IACpB2B,EAA4B,CAC5BC,OAAQ,CAAC,MAAO,MAAO,YAAa,OAAQ,SAAU,SAAU,SAAU,UAC1EC,KAAM,CAAC,MAAO,MAAO,YAAa,OAAQ,SAAU,SAAU,SAAU,UACxEC,KAAM,CAAC,MAAO,MAAO,YAAa,OAAQ,SAAU,SAAU,SAAU,UACxEC,QAAS,CAAC,MAAO,YAAa,OAAQ,SAAU,WAGhDrB,EAA4B,aAC5BL,EAAyB,QAGzB2B,EAAwB,CACxBC,QAAW,oBACXC,cAAe,oBACfC,OAAU,mBACVC,aAAc,oBAwWlB,OAzTAvC,EAAQwC,UAAUX,WAAa,SAAU1B,GAMrC,IALAA,EAAUA,GAAW,IACTa,cACRX,KAAKC,SAASU,YAAcb,EAAQa,aAGpCb,EAAQI,cAAe,CACvB,GAAIb,EAAE8B,SAASrB,EAAQI,eAAgB,CACnC,IAAIA,EAAgBJ,EAAQI,cAAckC,cAAcC,MAAM,KAClC,GAAxBnC,EAAcoC,QACkD,EAA5Db,EAA0BE,KAAKY,QAAQrC,EAAc,KACrDF,KAAKC,SAASG,qBAAuB,CACjCC,KAAMH,EAAc,IAExBF,KAAKC,SAASC,cAAgBC,IAE9BH,KAAKC,SAASC,cAAgBA,EAAc,GAC5CF,KAAKC,SAASG,qBAAuB,CACjCC,KAAM,QAIdL,KAAKC,SAASG,qBAAuB,CACjCC,KAAMH,EAAc,IAExBF,KAAKC,SAASC,cAAgBA,EAAc,SAEzCb,EAAEU,SAASD,EAAQI,iBAC1BF,KAAKC,SAASC,cAAgBJ,EAAQI,cAAcsC,QAAUrC,EAC9DH,KAAKC,SAASG,qBAAuBf,EAAEoD,KAAK3C,EAAQI,cAAe,WAGvE,IAAKV,EAAQkD,YAAY1C,KAAKC,SAASC,eACnC,MAAMyC,MAAM,8BAGhB,GAAI3C,KAAKC,SAASG,qBAAqBC,OACwE,IAA3GoB,EAA0BzB,KAAKC,SAASU,aAAa4B,QAAQvC,KAAKC,SAASG,qBAAqBC,MAChG,MAAMsC,MAAM,qCAAuC3C,KAAKC,SAASU,YAAc,gBAIvF,GAAIb,EAAQS,iBAAkB,CAS1B,GARIlB,EAAE8B,SAASrB,EAAQS,mBACnBP,KAAKC,SAASM,iBAAmBT,EAAQS,iBAAiB6B,cAC1DpC,KAAKC,SAASQ,wBAA0B,IACjCpB,EAAEU,SAASD,EAAQS,oBAC1BP,KAAKC,SAASM,iBAAmBT,EAAQS,iBAAiBiC,QAAUhC,EACpER,KAAKC,SAASQ,wBAA0BpB,EAAEoD,KAAK3C,EAAQS,iBAAkB,YAGxEf,EAAQoD,aAAa5C,KAAKC,SAASM,kBACpC,MAAMoC,MAAM,iCAGhB,GAAI3C,KAAKC,SAASQ,wBAAwBJ,OACwE,IAA9GoB,EAA0BzB,KAAKC,SAASU,aAAa4B,QAAQvC,KAAKC,SAASQ,wBAAwBJ,MACnG,MAAMsC,MAAM,qCAAuC3C,KAAKC,SAASU,YAAc,gBAIvFX,KAAKc,QAAQU,WAAWxB,KAAKC,WAUjCN,EAAQwC,UAAUd,gBAAkB,SAAUwB,EAAMC,GAIhD,GAFAA,EAAMA,GAAO,MAEI,IAHjBD,EAAOA,GAAQ,MAGJ,EACP,MAAMF,MAAM,qCAKhB,YAFK7B,QAAQiC,SAASF,EAAMC,EAAIE,SAAS,KACzChD,KAAKgB,OAAS,GACPhB,MAQXL,EAAQwC,UAAUf,UAAY,SAAU6B,EAASpD,GAC7C,IAAKoD,EACD,MAAMN,MAAM,mBAOhB,GAJI9C,IACAA,EAASiC,EAAsBjC,IAAWA,IAGzCJ,EAAQyD,gBAAgBlD,KAAKc,QAASmC,EAASpD,SAAW,IAAAA,EAC3D,MAAM8C,MAAM,gCAKhB,YAFK3B,OAAS,GAEPhB,MAOXL,EAAQwC,UAAUgB,UAAY,SAAUtD,GAQpC,OANAA,EAASiC,EADTjC,EAASA,GApKe,YAqKkBA,EAErCG,KAAKgB,OAAOnB,KACbG,KAAKgB,OAAOnB,GAAUJ,EAAQ2D,gBAAgBpD,KAAKc,QAASjB,IAGzDG,KAAKgB,OAAOnB,IAMvBF,EAAQwC,UAAUkB,UAAY,WAC1B,YAAYvC,QAAQuC,aAOxB1D,EAAQwC,UAAUmB,SAAW,SAAUC,GACnC,YAAYzC,QAAQwC,SAASC,IAMjC5D,EAAQwC,UAAUqB,QAAU,WACxB,QAASxD,KAAKc,QAAQ2C,GAAKzD,KAAKc,QAAQS,GAAKvB,KAAKc,QAAQ4C,IAW9D/D,EAAQwC,UAAUwB,QAAU,SAAUC,EAAQC,EAAUC,GACpD,YAAYC,gBAAoBH,EAAQC,EAAUC,IAUtDnE,EAAQwC,UAAU6B,QAAU,SAAUJ,EAAQC,GAC1C,YAAYI,gBAAoBL,EAAQC,IAQ5ClE,EAAQwC,UAAU+B,eAAiB,SAAUN,EAAQC,EAAUC,GAC3D,YAAYC,gBAAmBH,EAAQC,EAAUC,IAQrDnE,EAAQwC,UAAUgC,cAAgB,SAAUP,EAAQC,GAChD,YAAYI,gBAAmBL,EAAQC,IAM3ClE,EAAQwC,UAAU4B,aAAe,SAAUK,EAAYR,EAAQC,EAAUC,GACrE,IACI,IAAIO,EAAMrE,KAAKc,QAAQ6C,QAAQ3D,KAAKsE,mBAAmBV,EAAQE,GAAkBM,GADjF,MAGgB,UAAZP,GAAyBA,EAGlBQ,EAAIrB,SAASa,GAFbQ,EAIb,MAAO9C,GAEL,MADAgD,QAAQC,IAAIjD,GACNoB,MAAM,4CAA8CpB,KAOlE5B,EAAQwC,UAAU8B,aAAe,SAAUQ,EAAWb,EAAQC,GAC1D,IACID,EAASvE,EAAE8B,SAASyC,GAAU3C,OAAOyD,KAAKd,EAAQ,UAAYA,EAC9D,IAAIS,EAAMrE,KAAKc,QAAQkD,QAAQJ,EAAQa,GAEvC,GAAY,OAARJ,EACA,MAAM1B,MAAM,oCAGhB,YAAYgC,kBAAkBN,EAAKR,GACrC,MAAOtC,GACL,MAAMoB,MAAM,qEAAuEpB,KAY3F5B,EAAQwC,UAAUyC,KAAO,SAAUhB,EAAQC,EAAUC,GACjD,IAAK9D,KAAKqD,YACN,MAAMV,MAAM,2BAGhB,IAAI0B,EAAMrE,KAAKc,QAAQ8D,KAAK5E,KAAKsE,mBAAmBV,EAAQE,IAM5D,OAJID,GAAwB,UAAZA,IACZQ,EAAMA,EAAIrB,SAASa,IAGhBQ,GAYX1E,EAAQwC,UAAU0C,OAAS,SAAUjB,EAAQkB,EAAWhB,EAAiBiB,GACrE,IAAK/E,KAAKsD,WACN,MAAMX,MAAM,0BAGhB,OADAoC,EAAuBA,GAA4C,UAAtBA,EAAwCA,EAAP,KACvE/E,KAAKc,QAAQ+D,OAAO7E,KAAKsE,mBAAmBV,EAAQE,GAAkBgB,EAAWC,IAO5FpF,EAAQwC,UAAU6C,WAAa,WAC3B,YAAYlE,QAAQmE,SAOxBtF,EAAQwC,UAAU+C,kBAAoB,WAClC,YAAYpE,QAAQqE,kBAUxBxF,EAAQwC,UAAUmC,mBAAqB,SAAUV,EAAQC,GACrD,GAAIxE,EAAE8B,SAASyC,IAAWvE,EAAE+F,SAASxB,GACjC,OAAO3C,OAAOyD,KAAK,GAAKd,EAAQC,GAAY,QACzC,GAAI5C,OAAOC,SAAS0C,GACvB,OAAOA,EACJ,GAAIvE,EAAEU,SAAS6D,GAClB,OAAO3C,OAAOyD,KAAKW,EAAezB,IAElC,MAAMjB,MAAM,yBAUpBhD,EAAQwC,UAAUwC,kBAAoB,SAAUf,EAAQC,SAGpC,WAFhBA,EAAWA,GAAY,UAGZD,EACY,QAAZC,EACAhF,KAAKyG,MAAM1B,EAAOZ,YAElBY,EAAOZ,SAASa,IAIxBlE,EAxXI"}