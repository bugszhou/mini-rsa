(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, (function () {
		var current = global['mini-rsa'];
		var exports = global['mini-rsa'] = factory();
		exports.noConflict = function () { global['mini-rsa'] = current; return exports; };
	}()));
}(this, function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.9' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var $JSON = _core.JSON || (_core.JSON = { stringify: JSON.stringify });
	var stringify = function stringify(it) { // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

	var stringify$1 = stringify;

	var constants=require("constants"),rsa=require("./libs/rsa.js"),crypt=require("crypto"),ber=require("asn1").Ber,_=require("./utils")._,utils=require("./utils"),schemes=require("./schemes/schemes.js"),formats=require("./formats/formats.js");"undefined"==typeof constants.RSA_NO_PADDING&&(constants.RSA_NO_PADDING=3);var MiniRSA = (function(){function NodeRSA(key,format,options){return this instanceof NodeRSA?void(_.isObject(format)&&(options=format,format=void 0),this.$options={signingScheme:DEFAULT_SIGNING_SCHEME,signingSchemeOptions:{hash:"sha256",saltLength:null},encryptionScheme:DEFAULT_ENCRYPTION_SCHEME,encryptionSchemeOptions:{hash:"sha1",label:null},environment:utils.detectEnvironment(),rsaUtils:this},this.keyPair=new rsa.Key,this.$cache={},Buffer.isBuffer(key)||_.isString(key)?this.importKey(key,format):_.isObject(key)&&this.generateKeyPair(key.b,key.e),this.setOptions(options)):new NodeRSA(key,format,options)}var SUPPORTED_HASH_ALGORITHMS={node10:["md4","md5","ripemd160","sha1","sha224","sha256","sha384","sha512"],node:["md4","md5","ripemd160","sha1","sha224","sha256","sha384","sha512"],iojs:["md4","md5","ripemd160","sha1","sha224","sha256","sha384","sha512"],browser:["md5","ripemd160","sha1","sha256","sha512"]},DEFAULT_ENCRYPTION_SCHEME="pkcs1_oaep",DEFAULT_SIGNING_SCHEME="pkcs1",EXPORT_FORMAT_ALIASES={private:"pkcs1-private-pem","private-der":"pkcs1-private-der",public:"pkcs8-public-pem","public-der":"pkcs8-public-der"};return NodeRSA.prototype.setOptions=function(options){if(options=options||{},options.environment&&(this.$options.environment=options.environment),options.signingScheme){if(_.isString(options.signingScheme)){var signingScheme=options.signingScheme.toLowerCase().split("-");1==signingScheme.length?-1<SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0])?(this.$options.signingSchemeOptions={hash:signingScheme[0]},this.$options.signingScheme=DEFAULT_SIGNING_SCHEME):(this.$options.signingScheme=signingScheme[0],this.$options.signingSchemeOptions={hash:null}):(this.$options.signingSchemeOptions={hash:signingScheme[1]},this.$options.signingScheme=signingScheme[0]);}else _.isObject(options.signingScheme)&&(this.$options.signingScheme=options.signingScheme.scheme||DEFAULT_SIGNING_SCHEME,this.$options.signingSchemeOptions=_.omit(options.signingScheme,"scheme"));if(!schemes.isSignature(this.$options.signingScheme))throw Error("Unsupported signing scheme");if(this.$options.signingSchemeOptions.hash&&-1===SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash))throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}if(options.encryptionScheme){if(_.isString(options.encryptionScheme)?(this.$options.encryptionScheme=options.encryptionScheme.toLowerCase(),this.$options.encryptionSchemeOptions={}):_.isObject(options.encryptionScheme)&&(this.$options.encryptionScheme=options.encryptionScheme.scheme||DEFAULT_ENCRYPTION_SCHEME,this.$options.encryptionSchemeOptions=_.omit(options.encryptionScheme,"scheme")),!schemes.isEncryption(this.$options.encryptionScheme))throw Error("Unsupported encryption scheme");if(this.$options.encryptionSchemeOptions.hash&&-1===SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash))throw Error("Unsupported hashing algorithm for "+this.$options.environment+" environment")}this.keyPair.setOptions(this.$options);},NodeRSA.prototype.generateKeyPair=function(bits,exp){if(bits=bits||2048,exp=exp||65537,0!=bits%8)throw Error("Key size must be a multiple of 8.");return this.keyPair.generate(bits,exp.toString(16)),this.$cache={},this},NodeRSA.prototype.importKey=function(keyData,format){if(!keyData)throw Error("Empty key given");if(format&&(format=EXPORT_FORMAT_ALIASES[format]||format),!formats.detectAndImport(this.keyPair,keyData,format)&&void 0===format)throw Error("Key format must be specified");return this.$cache={},this},NodeRSA.prototype.exportKey=function(format){return format=format||"private",format=EXPORT_FORMAT_ALIASES[format]||format,this.$cache[format]||(this.$cache[format]=formats.detectAndExport(this.keyPair,format)),this.$cache[format]},NodeRSA.prototype.isPrivate=function(){return this.keyPair.isPrivate()},NodeRSA.prototype.isPublic=function(strict){return this.keyPair.isPublic(strict)},NodeRSA.prototype.isEmpty=function(){return !(this.keyPair.n||this.keyPair.e||this.keyPair.d)},NodeRSA.prototype.encrypt=function(buffer,encoding,source_encoding){return this.$$encryptKey(!1,buffer,encoding,source_encoding)},NodeRSA.prototype.decrypt=function(buffer,encoding){return this.$$decryptKey(!1,buffer,encoding)},NodeRSA.prototype.encryptPrivate=function(buffer,encoding,source_encoding){return this.$$encryptKey(!0,buffer,encoding,source_encoding)},NodeRSA.prototype.decryptPublic=function(buffer,encoding){return this.$$decryptKey(!0,buffer,encoding)},NodeRSA.prototype.$$encryptKey=function(usePrivate,buffer,encoding,source_encoding){try{var res=this.keyPair.encrypt(this.$getDataForEncrypt(buffer,source_encoding),usePrivate);return "buffer"!=encoding&&encoding?res.toString(encoding):res}catch(e){throw console.log(e),Error("Error during encryption. Original error: "+e)}},NodeRSA.prototype.$$decryptKey=function(usePublic,buffer,encoding){try{buffer=_.isString(buffer)?Buffer.from(buffer,"base64"):buffer;var res=this.keyPair.decrypt(buffer,usePublic);if(null===res)throw Error("Key decrypt method returns null.");return this.$getDecryptedData(res,encoding)}catch(e){throw Error("Error during decryption (probably incorrect key). Original error: "+e)}},NodeRSA.prototype.sign=function(buffer,encoding,source_encoding){if(!this.isPrivate())throw Error("This is not private key");var res=this.keyPair.sign(this.$getDataForEncrypt(buffer,source_encoding));return encoding&&"buffer"!=encoding&&(res=res.toString(encoding)),res},NodeRSA.prototype.verify=function(buffer,signature,source_encoding,signature_encoding){if(!this.isPublic())throw Error("This is not public key");return signature_encoding=signature_encoding&&"buffer"!=signature_encoding?signature_encoding:null,this.keyPair.verify(this.$getDataForEncrypt(buffer,source_encoding),signature,signature_encoding)},NodeRSA.prototype.getKeySize=function(){return this.keyPair.keySize},NodeRSA.prototype.getMaxMessageSize=function(){return this.keyPair.maxMessageLength},NodeRSA.prototype.$getDataForEncrypt=function(buffer,encoding){if(_.isString(buffer)||_.isNumber(buffer))return Buffer.from(""+buffer,encoding||"utf8");if(Buffer.isBuffer(buffer))return buffer;if(_.isObject(buffer))return Buffer.from(stringify$1(buffer));throw Error("Unexpected data type")},NodeRSA.prototype.$getDecryptedData=function(buffer,encoding){return encoding=encoding||"buffer","buffer"==encoding?buffer:"json"==encoding?JSON.parse(buffer.toString()):buffer.toString(encoding)},NodeRSA})();

	return MiniRSA;

}));
//# sourceMappingURL=mini-rsa.dev.js.map
